unit Core.Migration;

interface

uses
  System.Classes, System.SysUtils, System.Generics.Collections, System.IoUtils,

  FireDAC.Comp.Client, FireDAC.Comp.DataSet,
  FireDAC.Comp.ScriptCommands, FireDAC.Stan.Util, FireDAC.Comp.Script,

  Conn.Connection.DB.Firebird, Conn.connection.Singleton.Firebird;

type

  TMigration = class
  strict private
    const HistoryTableName = 'HISTORY_MIGRATION';
  private
    FConexao : TConnConnectionFirebird;
    ScriptExecutor : TFDScript;
    function GetListNoExecutedFiles(): TArray<String>;
    procedure InsertFilesOnDataBase;
    procedure CreateTheHistoryTable;
    procedure UpdateHistotyTable(Const ArrayOfFiles : TArray<String>);
    function HistoryTableExists: Boolean;
    procedure ExecuteScript(aFileName: String);
    procedure ConfigScriptExecutor;
  public
    constructor Create();
    Destructor Destroy(); override;

    function Execute():TMigration;
    class function New():TMigration;
  end;

implementation

{ TMigration }

uses common.Types;

constructor TMigration.Create;
begin
  inherited Create();
  Self.FConexao                  := TConexaoSingleton.GetInstance();
  Self.ScriptExecutor            := TFDSCript.Create(nil);
  Self.ConfigScriptExecutor();
end;

destructor TMigration.Destroy;
begin
  FreeAndNil(ScriptExecutor);
  inherited;
end;

procedure TMigration.ExecuteScript(aFileName:String);
begin

  Self.FConexao.StartTransaction();
  try
    ScriptExecutor.SQLScripts.Clear();
    ScriptExecutor.SQLScriptFileName := aFileName;

    if ScriptExecutor.ExecuteAll()
    then Self.FConexao.CommitTransaction()
    else self.FConexao.RollbackTransaction();
  except
    on E:Exception do begin
      Self.FConexao.RollbackTransaction();
      raise;
    end;

  end;

end;

function TMigration.Execute: TMigration;
begin
  Result := Self;
  Var ArrayOfFiles :TArray<String> := GetListNoExecutedFiles();

  for var sFileName : String in ArrayOfFiles do begin
    Var Dir := TPath.Combine(GetCurrentDir, sFileName);
    Self.ExecuteScript(Dir);
  end;
end;

class function TMigration.New: TMigration;
begin
  Result := TMigration.Create();

end;

function TMigration.GetListNoExecutedFiles():TArray<String>;
const
  _Sql:String = 'SELECT A.FILE_NAME FROM HISTORY_MIGRATION A WHERE NOT A.EXECUTED';
begin
  InsertFilesOnDataBase();
  var Query :TFDQuery := Self.FConexao.GetQuery(_Sql);
  try
    Query.First();
    SetLength(Result, Query.RecordCount);
    while not Query.eof do begin
      Result[pred(Query.RecNo)] := Query.FieldByName('FILE_NAME').AsString;

      Query.Next();
    end;
  finally
    FreeAndNil(Query);
  end;
end;

procedure TMigration.InsertFilesOnDataBase();
begin
  CreateTheHistoryTable();
  Var ArrayOfFiles : TArray<String> := TDirectory.GetFiles(GetCurrentDir, TFindFileExpression.Migration);
  UpdateHistotyTable(ArrayOfFiles);
end;

function TMigration.HistoryTableExists():Boolean;
const
  _Sql : String = 'Select RDB$RELATION_NAME from RDB$relations WHERE RDB$RELATION_NAME = %s;';
begin
  var Q :TFDQuery := Self.FConexao.GetQuery(_sql,[Self.HistoryTableName.QuotedString]);
  try
    Result := Q.RecordCount > 0;
  finally
    FreeAndNil(Q)
  end;

end;

procedure TMigration.CreateTheHistoryTable();
const
  _Sql:String = 'create table HISTORY_MIGRATION( ' +
                  'ID_HISTORY INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, ' +
                  'FILE_NAME VARCHAR(200) NOT NULL, ' +
                  'EXECUTION_TIME TIME, ' +
                  'EXECUTION_DATE DATE, ' +
                  'EXECUTION_DURATION TIME, ' +
                  'EXECUTED BOOLEAN DEFAULT FALSE' +
                '); ';

begin
  if HistoryTableExists() then exit();

  Self.FConexao.StartTransaction();
  try

    Self.FConexao.ExecuteCommand(_Sql);

    Self.FConexao.CommitTransaction();
  except
    on E:Exception do begin
      Self.FConexao.RollbackTransaction();
      raise;
    end;
  end;
end;

procedure TMigration.UpdateHistotyTable(Const ArrayOfFiles : TArray<String>);
Const
  _Sql : String = 'UPDATE OR INSERT INTO HISTORY_MIGRATION(FILE_NAME) VALUES(:FILE_NAME) MATCHING(FILE_NAME)';
begin
  var QueryFiles : TFDQuery := Self.FConexao.GetQuery(_Sql);
  try
    QueryFiles.Params.ArraySize := Length(ArrayOfFiles);

    for Var i:Integer := 0 to pred(length(ArrayOfFiles)) do
      QueryFiles.Params.ParamByName('FILE_NAME').AsStrings[i] := ExtractFileName(ArrayOfFiles[i]);

    Self.FConexao.StartTransaction();
    try
      QueryFiles.Execute(QueryFiles.Params.ArraySize);

      Self.FConexao.CommitTransaction();
    except
      on E: Exception do begin
        self.FConexao.RollbackTransaction();
        raise;
      end;
    end;
  finally
    FreeAndNil(QueryFiles);
  end;

end;

procedure TMigration.ConfigScriptExecutor();
begin
  Self.ScriptExecutor.Connection := Self.FConexao.GetConnection;
  Self.ScriptExecutor.ScriptOptions.CommitEachNCommands := 1;
  Self.ScriptExecutor.ScriptOptions.EchoCommandTrim := 0;
  Self.ScriptExecutor.ScriptOptions.MaxStringWidth := 0;
  Self.ScriptExecutor.ScriptOptions.BreakOnError := True;
  Self.ScriptExecutor.ScriptOptions.MacroExpand := False;
  Self.ScriptExecutor.ScriptOptions.DriverID := Self.FConexao.GetConnection.Params.DriverID;
  Self.ScriptExecutor.ScriptOptions.SQLDialect := 3;
  Self.ScriptExecutor.ScriptOptions.RaisePLSQLErrors := True;
  Self.ScriptExecutor.FormatOptions.StrsEmpty2Null := True;
  //Self.ScriptExecutor.OnConsolePut := ScriptConsolePut;
  //Self.ScriptExecutor.OnError      := ScriptError;

end;

end.
